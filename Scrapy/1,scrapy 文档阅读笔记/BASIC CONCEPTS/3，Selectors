【Css ,Xpath】


Response objects expose a Selector instance on .selector attribute:
>>>response.selector.xpath('//span/text()').get()


Querying responses using XPath and CSS is so common that responses
include two more shortcuts: response.xpath() and response.css():
>>> response.xpath('//span/text()').get()
>>> response.css('span::text').get()


But if required, it is possible to use Selector directly. Constructing from text:
>>> from scrapy.selector import Selector
>>> body = '<html><body><span>good</span></body></html>'
>>> Selector(text=body).xpath('//span/text()').get()
'good'


Constructing from response - HtmlResponse is one of TextResponse subclasses:
>>> from scrapy.selector import Selector
>>> from scrapy.http import HtmlResponse
>>> response = HtmlResponse(url='http://example.com', body=body)
>>> Selector(response=response).xpath('//span/text()').get()
'good'


>>> response.xpath('//title/text()').getall()
['Example website']
>>> response.xpath('//title/text()').get()
'Example website'
[.get()] always returns a single result; if there are several matches,
content of a first match is returned; if there are no matches, None is returned.
[.getall()] returns a list with all results.


As you can see, .xpath() and .css() methods return a SelectorList instance
>>> response.css('img').xpath('@src').getall()


If you want to extract only the first matched element, you can call the selector
[.get()] (or its alias [.extract_first()] commonly used in previous Scrapy versions)


Instead of using e.g. '@src' XPath it is possible to
query for attributes using .attrib property of a Selector:
>>> [img.attrib['src'] for img in response.css('img')]


As a shortcut, .attrib is also available on SelectorList directly;
it returns attributes for the first matching element:
>>> response.css('img').attrib['src']


[Scrapy 自己实现的两个CSS选择器属性-- ::text, ::attr(name)
Per W3C standards, CSS selectors do not support selecting text nodes or attribute values. But selecting these is so essential in a web scraping context that Scrapy (parsel) implements a couple of non-standard pseudo-elements:
[::text]to select text nodes, use ::text
[::attr(name)]to select attribute values, use ::attr(name) where name is the name of the attribute that you want the value of
title::text selects children text nodes of a descendant <title> element:
>>> response.css('title::text').get()
*::text selects all descendant text nodes of the current selector context:
>>> response.css('#images *::text').getall()
foo::text returns no results if foo element exists, but contains no text (i.e. text is empty):
>>> response.css('img::text').getall()
[]
 Use default='' if you always want a string:
>>> response.css('img::text').get()
>>> response.css('img::text').get(default='hello')
'hello'

a::attr(href) selects the href attribute value of descendant links:
>>> response.css('a::attr(href)').getall()


【Nesting selectors ---嵌套Selectors】
>>> links.getall()
['<a href="image1.html">Name: My image 1 <br><img src="image1_thumb.jpg"></a>',
 '<a href="image2.html">Name: My image 2 <br><img src="image2_thumb.jpg"></a>',
 '<a href="image3.html">Name: My image 3 <br><img src="image3_thumb.jpg"></a>',
 '<a href="image4.html">Name: My image 4 <br><img src="image4_thumb.jpg"></a>',
 '<a href="image5.html">Name: My image 5 <br><img src="image5_thumb.jpg"></a>']

>>> for index, link in enumerate(links):
...     args = (index, link.xpath('@href').get(), link.xpath('img/@src').get())
...     print('Link number %d points to url %r and image %r' % args)

Link number 0 points to url 'image1.html' and image 'image1_thumb.jpg'
Link number 1 points to url 'image2.html' and image 'image2_thumb.jpg'
Link number 2 points to url 'image3.html' and image 'image3_thumb.jpg'
Link number 3 points to url 'image4.html' and image 'image4_thumb.jpg'
Link number 4 points to url 'image5.html' and image 'image5_thumb.jpg'


>>> response.css('base').attrib
{'href': 'http://example.com/'}
>>> response.css('base').attrib['href']
'http://example.com/'


Selector also has a .re() method for extracting data using regular expressions.
However, unlike using .xpath() or .css() methods, .re() returns
a list of unicode strings. So you can’t construct nested .re() calls.
>>> response.xpath('//a[contains(@href, "image")]/text()').re(r'Name:\s*(.*)')


There’s an additional helper reciprocating .get() (and its alias .extract_first()) for .re(), named .re_first().
Use it to extract just the first matching string:
>>> response.xpath('//a[contains(@href, "image")]/text()').re_first(r'Name:\s*(.*)')


SelectorList.get() is the same as SelectorList.extract_first():
>>> response.css('a::attr(href)').get()
'image1.html'
>>> response.css('a::attr(href)').extract_first()
'image1.html'
SelectorList.getall() is the same as SelectorList.extract():
>>> response.css('a::attr(href)').getall()
['image1.html', 'image2.html', 'image3.html', 'image4.html', 'image5.html']
>>> response.css('a::attr(href)').extract()
['image1.html', 'image2.html', 'image3.html', 'image4.html', 'image5.html']
Selector.get() is the same as Selector.extract():
>>> response.css('a::attr(href)')[0].get()
'image1.html'
>>> response.css('a::attr(href)')[0].extract()
'image1.html'
For consistency, there is also Selector.getall(), which returns a list:
>>> response.css('a::attr(href)')[0].getall()
['image1.html']
the main difference is that output of .get() and .getall() methods is more predictable:
.get() always returns a single result,
.getall() always returns a list of all extracted results.
With .extract() method it was not always obvious if a result is a list or not;
to get a single result either .extract() or .extract_first() should be called.


【当通过类来筛选元素时，使用CSS而不是Xpath】
When querying by class, consider using CSS
Because an element can contain multiple CSS classes,
the XPath way to select elements by class is the rather verbose:


When you need to use the text content as argument to an XPath string function,
avoid using .//text() and use just . instead.
This is because the expression .//text() yields a collection of
text elements – a node-set. And when a node-set is converted to a string,
which happens when it is passed as argument to a string function like contains()
or starts-with(), it results in the text for the first element only.


