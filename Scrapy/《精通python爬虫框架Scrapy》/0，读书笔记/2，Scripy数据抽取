这里使用了一个response对象，并调用了它的xpath()方法
来抽取感兴趣的值。不过，xpath()返回的值是什么呢？如果在
一个简单的XPath表达式中，不使用.extract()方法，将会得到
如下的显示输出：
>>> response.xpath('.')
[<Selector xpath='.' data=u'<html>\n<head>\n<meta
charse'>]
xpath()返回了网页内容预加载的Selector对象。我们目前
只使用了xpath()方法，不过它还有另一个有用的方
法：css()。xpath()和css()都会返回选择器，只有当调
用extract()或re()方法的时候，才会得到真实的文本数组。这
种方式非常好用，因为这样就可以将xpath()和css()操作串联起
来了。比如，可以使用css()快速抽取正确的HTML元素。
>>> response.css('.ad-price')
[<Selector xpath=u"descendant-or-self::*[@class and
contains(concat(' ', normalize-space(@class), ' '), '
ad-price ')]" data=u'<strong class="ad-price txt-xlarge
txt-e'>]
请注意，在后台中css()实际上编译了一个xpath()表达式，
不过我们输入的内容要比XPath自身更加简单。接下来，串联一
个xpath()方法，只抽取其中的文本。
>>> response.css('.ad-price').xpath('text()')
[<Selector xpath='text()' data=u'\xa3334.39pw'>]
最后，还可以通过re()方法，串联上正则表达式，以抽取感
兴趣的值。
>>> response.css('.ad-price').xpath('text()').re('[.0-
9]+')
[u'334.39']
实际上，这个表达式与原始表达式相比，并无好坏之差。请
把它当作一个引起思考的说明性示例。在本书中，我们将尽可能
保持事物简单，同时也会尽可能多地使用虽然有些老旧但仍然好
用的XPath。关键点是记住xpath()和css()返回的Selector对象
是可以被串联起来的。为了获取真实值，可以使用extract()，
也可以使用re()。