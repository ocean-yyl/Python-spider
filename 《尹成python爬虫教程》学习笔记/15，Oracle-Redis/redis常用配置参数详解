Redis 支持很多的参数，但都有默认值。
daemonize
默认情况下， redis 不是在后台运行的，如果需要在后台运行，把该项的值更改为 yes。


pidfile
当 Redis 在后台运行的时候， Redis 默认会把 pid 文件放在/var/run/redis.pid，你可以配
置到其他地址。当运行多个 redis 服务时，需要指定不同的 pid 文件和端口


bind
指定 Redis 只接收来自于该 IP 地址的请求，如果不进行设置，那么将处理所有请求，在
生产环境中最好设置该项


port
监听端口，默认为 6379


timeout
设置客户端连接时的超时时间，单位为秒。当客户端在这段时间内没有发出任何指令，
那么关闭该连接


loglevel
log 等级分为 4 级， debug, verbose, notice, 和 warning。生产环境下一般开启 notice


logfile
配置 log 文件地址，默认使用标准输出，即打印在命令行终端的窗口上


databases
设置数据库的个数，可以使用 SELECT <dbid>命令来切换数据库。默认使用的数据库是 0


save
设置 Redis 进行数据库镜像的频率。
if(在 60 秒之内有 10000 个 keys 发生变化时){
进行镜像备份
}else if(在 300 秒之内有 10 个 keys 发生了变化){
进行镜像备份
}else if(在 900 秒之内有 1 个 keys 发生了变化){
进行镜像备份
}


rdbcompression
在进行镜像备份时，是否进行压缩


dbfilename
镜像备份文件的文件名


dir
数据库镜像备份的文件放置的路径。这里的路径跟文件名要分开配置是因为 Redis 在进行备份时，先会将当前数据库的状态写入到一个临时文件中，等备份完成时，再把该该
临时文件替换为上面所指定的文件，而这里的临时文件和上面所配置的备份文件都会放
在这个指定的路径当中


slaveof
设置该数据库为其他数据库的从数据库


masterauth
当主数据库连接需要密码验证时，在这里指定


requirepass
设置客户端连接后进行任何其他指定前需要使用的密码。警告：因为 redis 速度相当快，
所以在一台比较好的服务器下，一个外部的用户可以在一秒钟进行 150K 次的密码尝试，
这意味着你需要指定非常非常强大的密码来防止暴力破解。


maxclients
限制同时连接的客户数量。当连接数超过这个值时， redis 将不再接收其他连接请求，
客户端尝试连接时将收到 error 信息。


maxmemory
设置 redis 能够使用的最大内存。当内存满了的时候，如果还接收到 set 命令， redis 将
先尝试剔除设置过 expire 信息的 key，而不管该 key 的过期时间还没有到达。在删除时，
将按照过期时间进行删除，最早将要被过期的 key 将最先被删除。如果带有 expire 信息
的 key 都删光了，那么将返回错误。这样， redis 将不再接收写请求，只接收 get 请求。
maxmemory 的设置比较适合于把 redis 当作于类似 memcached 的缓存来使用。


appendonly
默认情况下， redis 会在后台异步的把数据库镜像备份到磁盘，但是该备份是非常耗时
的，而且备份也不能很频繁，如果发生诸如拉闸限电、拔插头等状况，那么将造成比较
大范围的数据丢失。所以 redis 提供了另外一种更加高效的数据库备份及灾难恢复方式。
开启 append only 模式之后， redis 会把所接收到的每一次写操作请求都追加到
appendonly.aof 文件中，当 redis 重新启动时，会从该文件恢复出之前的状态。但是这样
会造成 appendonly.aof 文件过大，所以 redis 还支持了 BGREWRITEAOF 指令，对
appendonly.aof 进行重新整理。所以我认为推荐生产环境下的做法为关闭镜像，开启
appendonly.aof，同时可以选择在访问较少的时间每天对 appendonly.aof 进行重写一次。


appendfsync
设置对 appendonly.aof 文件进行同步的频率。 always 表示每次有写操作都进行同步，
everysec 表示对写操作进行累积，每秒同步一次。这个需要根据实际业务场景进行配置


vm-enabled
是否开启虚拟内存支持。因为 redis 是一个内存数据库，而且当内存满的时候，无法接
收新的写请求，所以在 redis 2.0 中，提供了虚拟内存的支持。但是需要注意的是， redis
中，所有的 key 都会放在内存中，在内存不够时，只会把 value 值放入交换区。这样保
证了虽然使用虚拟内存，但性能基本不受影响，同时，你需要注意的是你要把
vm-max-memory 设置到足够来放下你的所有的 key


vm-swap-file
设置虚拟内存的交换文件路径


vm-max-memory
这里设置开启虚拟内存之后， redis 将使用的最大物理内存的大小。默认为 0， redis 将
把他所有的能放到交换文件的都放到交换文件中，以尽量少的使用物理内存。在生产环
境下，需要根据实际情况设置该值，最好不要使用默认的 0


vm-page-size
设置虚拟内存的页大小，如果你的 value 值比较大，比如说你要在 value 中放置博客、
新闻之类的所有文章内容，就设大一点，如果要放置的都是很小的内容，那就设小一点。


vm-pages
设置交换文件的总的 page 数量， 需要注意的是， page table 信息会放在物理内存中，每
8 个 page 就会占据 RAM 中的 1 个 byte。总的虚拟内存大小 ＝ vm-page-size * vm-pages


vm-max-threads
设置 VM IO 同时使用的线程数量。因为在进行内存交换时，对数据有编码和解码的过
程，所以尽管 IO 设备在硬件上本上不能支持很多的并发读写，但是还是如果你所保存
的 vlaue 值比较大，将该值设大一些，还是能够提升性能的


glueoutputbuf
把小的输出缓存放在一起，以便能够在一个 TCP packet 中为客户端发送多个响应，具体
原理和真实效果我不是很清楚。所以根据注释，你不是很确定的时候就设置成 yes


hash-max-zipmap-entries
在 redis 2.0 中引入了 hash 数据结构。当 hash 中包含超过指定元素个数并且最大的元素
没有超过临界时， hash 将以一种特殊的编码方式（大大减少内存使用）来存储，这里
可以设置这两个临界值

activerehashing
开启之后， redis 将在每 100 毫秒时使用 1 毫秒的 CPU 时间来对 redis 的 hash 表进行重新 hash，可以降低内存的使用。当你的使用场景中，有非常严格的实时性需要，不能
够接受 Redis 时不时的对请求有 2 毫秒的延迟的话，把这项配置为 no。如果没有这么严
格的实时性要求，可以设置为 yes，以便能够尽可能快的释放内存