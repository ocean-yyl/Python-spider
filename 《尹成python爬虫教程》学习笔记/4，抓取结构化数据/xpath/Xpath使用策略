1，对于大型文档，可能需要写一个非常长的Xpath表达式以访问指定元素。为了避免这个问题，可以使用//语法。
它可以让你取得某一特定类型的元素，而无需考虑其所在的层次结构。比如：//p会选择所有的p元素，而//a会选择所有的链接。

同样，//a语法也可以在层次结构中的任何地方使用。比如，想要找到所有div元素下的所有链接，可以使用//div//a。需要注意的是，只是用单斜线的//div/a将会得到div元素的直接下级a元素，若没有直接下级a元素，返回空数组。

2，编写xpath，预见变化——你应该尽可能使你的xpath表达式适用的时间更长。虽然，网页源码经常在变。

抓取时经常会指向我们无法控制的服务器页面，这就意味着如果它们的html以某种方式发生变化后，就会使Xpath表达式失效。我们将不得不回到爬虫中去修改。这种情况应尽量避免，可以使用一下简单的规则。

A，避免使用数组索引（数字）
直接从chrome复制过来的表达式经常包含大量常数。
/html/body/div[3]/section/div[2]/div/article/div[3]/div[3]/div/ol/li[1]/div[2]/p[4]
这种方式非常脆弱，如果像广告这种东西在层次结构中的某个地方添加了一个额外div的话，这些数字就会指向不同的元素。

———尽可能接近目标的标签，找到一个可以使用的包含id或者class属性的元素。如：
//div[@class="tddls"]/a/img


B,类并没有那么好用
使用class属性可以更加容易地精确定位元素，不过这些属性一般是用于通过CSS影响页面外观地，因此可能会由于网站布局的微小变化而产生变化。


C，有意义的面向数据的类要比具体的或者面向布局的类更好。
[@class="green block"] 明显是面向布局
[@class='password'] 明显是面向数据

D，ID通常是最可靠的